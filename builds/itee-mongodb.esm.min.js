import{isDefined as e,isArray as r,isObject as t,isString as s,isFunction as a,isNotDefined as n,isEmptyArray as o,isEmptyObject as i,isNotString as u,isEmptyString as l,isBlankString as c,isNotArray as d,isNotObject as p,isNull as h,isUndefined as m,isInvalidDirectoryPath as f,isEmptyFile as _}from"itee-validators";import g from"path";import{kStringMaxLength as b}from"buffer";import E from"fs";import{Writable as y}from"stream";import{getFilesPathsUnder as v}from"itee-utils";import*as w from"mongoose";console.log("Itee.Database v8.0.2 - EsModule");
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class TDatabaseController
 * @classdesc The TDatabaseController is the base class to perform CRUD operations on the database
 */
class x{static __checkData(r,t,s){const a=t.body,n=t.params,o=t.query;return e(a)&&a[r]?a[r]:e(n)&&n[r]?n[r]:e(o)&&o[r]?o[r]:void x.returnError({title:"Erreur de paramètre",message:`${r} n'existe pas dans les paramètres !`},s)}static _formatError(e){let a=[];if(r(e))for(let r=0,t=e.length;r<t;++r)a=a.concat(x._formatError(e[r]));else if(t(e))if("ValidationError"===e.name){let r="",t=e.errors;for(let e in t)Object.prototype.hasOwnProperty.call(t,e)&&(r+=t[e].message+"<br>");a.push({title:"Erreur de validation",message:r||"Aucun message d'erreur... Gloups !"})}else"VersionError"===e.name?a.push({title:"Erreur de base de donnée",message:"Aucun document correspondant n'as put être trouvé pour la requete !"}):a.push({title:e.title||"Erreur",message:e.message||"Aucun message d'erreur... Gloups !"});else{if(!s(e))throw new Error(`Unknown error type: ${e} !`);a.push({title:"Erreur",message:e})}return a}static returnNotFound(e){if(a(e))return e();e.headersSent||e.status(204).end()}static returnError(e,r){if(a(r))return r(e,null);if(r.headersSent)return;const t=x._formatError(e);r.format({"application/json":()=>{r.status(500).json(t)},default:()=>{r.status(406).send("Not Acceptable")}})}static returnData(e,t){if(a(t))return t(null,e);if(t.headersSent)return;const s=r(e)?e:[e];t.format({"application/json":()=>{t.status(200).json(s)},default:()=>{t.status(406).send("Not Acceptable")}})}static returnErrorAndData(e,r,t){if(a(t))return t(e,r);if(t.headersSent)return;const s={errors:e,datas:r};t.format({"application/json":()=>{t.status(416).json(s)},default:()=>{t.status(416).send("Range Not Satisfiable")}})}constructor(e={}){const r={driver:null,useNext:!1,...e};this._driver=r.driver,this._useNext=r.useNext}return(r,t={}){const s=Object.assign({immediate:null,beforeAll:null,beforeReturnErrorAndData:null,afterReturnErrorAndData:null,beforeReturnError:null,afterReturnError:null,beforeReturnData:null,afterReturnData:null,beforeReturnNotFound:null,afterReturnNotFound:null,afterAll:null},t,{returnErrorAndData:x.returnErrorAndData.bind(this),returnError:x.returnError.bind(this),returnData:x.returnData.bind(this),returnNotFound:x.returnNotFound.bind(this)});return s.immediate&&s.immediate(),function(t=null,a=null){const n=e(a),o=e(t);s.beforeAll&&s.beforeAll(),n&&o?(s.beforeReturnErrorAndData&&s.beforeReturnErrorAndData(t,a),s.returnErrorAndData(t,a,r),s.afterReturnErrorAndData&&s.afterReturnErrorAndData(t,a)):n&&!o?(s.beforeReturnData&&s.beforeReturnData(a),s.returnData(a,r),s.afterReturnData&&s.afterReturnData(a)):!n&&o?(s.beforeReturnError&&s.beforeReturnError(t),s.returnError(t,r),s.afterReturnError&&s.afterReturnError(t)):n||o||(s.beforeReturnNotFound&&s.beforeReturnNotFound(),s.returnNotFound(r),s.afterReturnNotFound&&s.afterReturnNotFound()),s.afterAll&&s.afterAll()}}create(e,s,a){const u=e.body;n(u)?x.returnError({title:"Erreur de paramètre",message:"Le corps de la requete ne peut pas être null ou indefini."},this._useNext?a:s):r(u)?o(u)?x.returnError({title:"Erreur de paramètre",message:"Le tableau d'objet de la requete ne peut pas être vide."},this._useNext?a:s):this._createMany(u,s,a):t(u)?i(u)?x.returnError({title:"Erreur de paramètre",message:"L'objet de la requete ne peut pas être vide."},this._useNext?a:s):this._createOne(u,s,a):x.returnError({title:"Erreur de paramètre",message:"Le type de donnée de la requete est invalide. Les paramètres valides sont objet ou un tableau d'objet."},this._useNext?a:s)}_createOne(){}_createMany(){}read(r,t,s){const a=r.params.id,n=r.body,h=e(n),m=h?n.ids:null,f=h?n.query:null,_=h?n.projection:null;e(a)?u(a)?x.returnError({title:"Erreur de paramètre",message:"L'identifiant devrait être une chaine de caractères."},this._useNext?s:t):l(a)||c(a)?x.returnError({title:"Erreur de paramètre",message:"L'identifiant ne peut pas être une chaine de caractères vide."},this._useNext?s:t):this._readOne(a,_,t,s):e(m)?d(m)?x.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants devrait être un tableau de chaine de caractères."},this._useNext?s:t):o(m)?x.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants ne peut pas être vide."},this._useNext?s:t):this._readMany(m,_,t,s):e(f)?p(f)?x.returnError({title:"Erreur de paramètre",message:"La requete devrait être un objet javascript."},this._useNext?s:t):i(f)?this._readAll(_,t,s):this._readWhere(f,_,t,s):x.returnError({title:"Erreur de paramètre",message:"La requete ne peut pas être null."},this._useNext?s:t)}_readOne(){}_readMany(){}_readWhere(){}_readAll(){}update(r,t,s){const a=r.params.id,h=r.body,m=e(h),f=m?h.ids:null,_=m?h.query:null,g=m?h.update:null;n(g)?x.returnError({title:"Erreur de paramètre",message:"La mise à jour a appliquer ne peut pas être null ou indefini."},this._useNext?s:t):e(a)?u(a)?x.returnError({title:"Erreur de paramètre",message:"L'identifiant devrait être une chaine de caractères."},this._useNext?s:t):l(a)||c(a)?x.returnError({title:"Erreur de paramètre",message:"L'identifiant ne peut pas être une chaine de caractères vide."},this._useNext?s:t):this._updateOne(a,g,t,s):e(f)?d(f)?x.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants devrait être un tableau de chaine de caractères."},this._useNext?s:t):o(f)?x.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants ne peut pas être vide."},this._useNext?s:t):this._updateMany(f,g,t,s):e(_)?p(_)?x.returnError({title:"Erreur de paramètre",message:"La requete devrait être un objet javascript."},this._useNext?s:t):i(_)?this._updateAll(g,t,s):this._updateWhere(_,g,t,s):x.returnError({title:"Erreur de paramètre",message:"La requete ne peut pas être vide."},this._useNext?s:t)}_updateOne(){}_updateMany(){}_updateWhere(){}_updateAll(){}delete(r,t,s){const a=r.params.id,n=r.body,h=e(n),m=h?n.ids:null,f=h?n.query:null;e(a)?u(a)?x.returnError({title:"Erreur de paramètre",message:"L'identifiant devrait être une chaine de caractères."},this._useNext?s:t):l(a)||c(a)?x.returnError({title:"Erreur de paramètre",message:"L'identifiant ne peut pas être une chaine de caractères vide."},this._useNext?s:t):this._deleteOne(a,t,s):e(m)?d(m)?x.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants devrait être un tableau de chaine de caractères."},this._useNext?s:t):o(m)?x.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants ne peut pas être vide."},this._useNext?s:t):this._deleteMany(m,t,s):e(f)?p(f)?x.returnError({title:"Erreur de paramètre",message:"La requete devrait être un objet javascript."},this._useNext?s:t):i(f)?this._deleteAll(t,s):this._deleteWhere(f,t,s):x.returnError({title:"Erreur de paramètre",message:"La requete ne peut pas être vide."},this._useNext?s:t)}_deleteOne(){}_deleteMany(){}_deleteWhere(){}_deleteAll(){}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class A extends y{constructor(e){super(e);const r=e.bufferSize||b;this.memoryBuffer=Buffer.alloc(r),this.offset=0}_final(e){e()}_write(e,r,t){const s=Buffer.isBuffer(e)?e:new Buffer(e,r);for(let e=0,r=s.length;e<r;e++)this.memoryBuffer[this.offset]=s[e],this.offset++;t()}_writev(e,r){for(let r=0,t=e.length;r<t;r++)this.memoryBuffer=Buffer.concat([this.memoryBuffer,e[r]]);r()}_releaseMemory(){this.memoryBuffer=null}toArrayBuffer(){const e=this.memoryBuffer,r=new ArrayBuffer(e.length),t=new Uint8Array(r);for(let r=0;r<e.length;++r)t[r]=e[r];return this._releaseMemory(),r}toJSON(){return JSON.parse(this.toString())}toString(){const e=this.memoryBuffer.toString();return this._releaseMemory(),e}}class S{constructor(e={}){const r={dumpType:S.DumpType.ArrayBuffer,...e};this.dumpType=r.dumpType,this._isProcessing=!1,this._queue=[]}get dumpType(){return this._dumpType}set dumpType(e){if(h(e))throw new TypeError("Dump type cannot be null ! Expect a non empty string.");if(m(e))throw new TypeError("Dump type cannot be undefined ! Expect a non empty string.");this._dumpType=e}setDumpType(e){return this.dumpType=e,this}convert(e,r,t,s,a){e?(this._queue.push({file:e,parameters:r,onSuccess:t,onProgress:s,onError:a}),this._processQueue()):a("File cannot be null or empty, aborting file convertion !!!")}_processQueue(){if(0===this._queue.length||this._isProcessing)return;this._isProcessing=!0;const e=this,r=this._queue.shift(),t=r.file,a=r.parameters,n=r.onSuccess,o=r.onProgress,i=r.onError;if(s(t))e._dumpFileInMemoryAs(e._dumpType,t,a,u,c,d);else{const r=t.data;switch(e._dumpType){case S.DumpType.ArrayBuffer:{const e=r.length,t=new ArrayBuffer(e),s=new Uint8Array(t);for(let t=0;t<e;++t)s[t]=r[t];u(t)}break;case S.DumpType.JSON:u(JSON.parse(r.toString()));break;case S.DumpType.String:u(r.toString());break;default:throw new RangeError(`Invalid switch parameter: ${e._dumpType}`)}}function u(r){e._convert(r,a,l,c,d)}function l(r){n(r),e._isProcessing=!1,e._processQueue()}function c(e){o(e)}function d(r){i(r),e._isProcessing=!1,e._processQueue()}}_dumpFileInMemoryAs(e,r,t,s,a,n){let o=!1;const i=E.createReadStream(r);i.on("error",e=>{o=!0,n(e)});const u=parseInt(t.fileSize),l=new A({bufferSize:u});l.on("error",e=>{o=!0,n(e)}),l.on("finish",()=>{if(!o){switch(e){case S.DumpType.ArrayBuffer:s(l.toArrayBuffer());break;case S.DumpType.String:s(l.toString());break;case S.DumpType.JSON:s(l.toJSON());break;default:throw new RangeError(`Invalid switch parameter: ${e}`)}i.unpipe(),i.close(),l.end()}}),i.pipe(l)}_convert(){}}S.MAX_FILE_SIZE=67108864,S.DumpType=Object.freeze({ArrayBuffer:0,String:1,JSON:2});
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
class D{static _registerRoutesTo(e,r,t,s,a){for(let n=0,o=a.length;n<o;n++){const o=a[n],i=new(s.get(o.controller.name))({driver:e,...o.controller.options}),u=t({mergeParams:!0});console.log(`\tAdd controller for base route: ${o.route}`),r.use(o.route,D._populateRouter(u,i,o.controller.can))}}static _populateRouter(e,r,t={}){for(let s in t){const a=t[s];console.log(`\t\tMap route ${a.over} on (${a.on}) to ${r.constructor.name}.${s} method.`),e[a.on](a.over,r[s].bind(r))}return e}constructor(e={}){const r={controllers:new Map,descriptors:[],...e};this.controllers=r.controllers,this.descriptors=r.descriptors,this.__dirname=void 0}get controllers(){return this._controllers}set controllers(e){if(h(e))throw new TypeError("Controllers cannot be null ! Expect a map of controller.");if(m(e))throw new TypeError("Controllers cannot be undefined ! Expect a map of controller.");if(!(e instanceof Map))throw new TypeError(`Controllers cannot be an instance of ${e.constructor.name} ! Expect a map of controller.`);this._controllers=e}get descriptors(){return this._descriptors}set descriptors(e){if(h(e))throw new TypeError("Descriptors cannot be null ! Expect an array of POJO.");if(m(e))throw new TypeError("Descriptors cannot be undefined ! Expect an array of POJO.");this._descriptors=e}addController(e){return this._controllers.set(e.name,e),this}addDescriptor(e){return this._descriptors.push(e),this}beforeRegisterRoutes(){}registerTo(e,r,t){this.beforeRegisterRoutes(e),D._registerRoutesTo(e,r,t,this._controllers,this._descriptors)}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class TMongooseController
 * @classdesc The TMongooseController is the base class to perform CRUD operations on the database
 */
class T extends x{constructor(e={}){const r={driver:null,schemaName:"",...e};super(r),this.databaseSchema=this._driver.model(r.schemaName)}get databaseSchema(){return this._databaseSchema}set databaseSchema(e){if(h(e))throw new TypeError("Database schema cannot be null.");if(m(e))throw new TypeError("Database schema cannot be undefined.");this._databaseSchema=e}setDatabaseSchema(e){return this.databaseSchema=e,this}_createMany(e,r){super._createMany(e,r),this._databaseSchema.create(e,this.return(r))}_createOne(e,r){super._createOne(e,r),this._databaseSchema.create(e,this.return(r))}_deleteAll(e){super._deleteAll(e),this._databaseSchema.collection.drop(this.return(e))}_deleteMany(e,r){super._deleteMany(e,r),this._databaseSchema.deleteMany({_id:{$in:e}},this.return(r))}_deleteOne(e,r){super._deleteOne(e,r),this._databaseSchema.findByIdAndDelete(e).then(e=>x.returnData(e,r)).catch(e=>x.returnError(e,r))}_deleteWhere(e,r){super._deleteWhere(e,r),this._databaseSchema.deleteMany(e,this.return(r))}_readAll(e,r){super._readAll(e,r),this._databaseSchema.find({},e).lean().exec().then(e=>x.returnData(e,r)).catch(e=>x.returnError(e,r))}_readMany(e,r,t){super._readMany(e,r,t),this._databaseSchema.find({_id:{$in:e}},r).lean().exec().then(r=>{h(r)||o(r)?x.returnNotFound(t):e.length!==r.length?x.returnErrorAndData({title:"Missing data",message:"Some requested objects could not be found."},r,t):x.returnData(r,t)}).catch(e=>x.returnError(e,t))}_readOne(e,r,t){super._readOne(e,r,t),this._databaseSchema.findById(e,r).lean().exec().then(e=>{h(e)?x.returnNotFound(t):x.returnData(e,t)}).catch(e=>x.returnError(e,t))}_readWhere(e,r,t){super._readWhere(e,r,t),this._databaseSchema.find(e,r).lean().exec().then(e=>x.returnData(e,t)).catch(e=>x.returnError(e,t))}_updateAll(e,r){super._updateAll(e,r),this._databaseSchema.update({},e,{multi:!0},this.return(r))}_updateMany(e,r,t){super._updateMany(e,r,t),this._databaseSchema.update({_id:{$in:e}},r,{multi:!0},this.return(t))}_updateOne(e,r,t){super._updateOne(e,r,t),this._databaseSchema.findByIdAndUpdate(e,r).exec().then(e=>x.returnData(e,t)).catch(e=>x.returnError(e,t))}_updateWhere(e,r,t){super._updateWhere(e,r,t),this._databaseSchema.update(e,r,{multi:!0},this.return(t))}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class N extends D{constructor(e={}){const r={types:[],schemas:[],...e};super(r),this.types=r.types,this.schemas=r.schemas}get schemas(){return this._schemas}set schemas(e){this._schemas=e}get types(){return this._types}set types(e){this._types=e}addSchema(e){return this._schemas.push(e),this}addType(e){return this._types.push(e),this}beforeRegisterRoutes(e){super.beforeRegisterRoutes(e),this._searchLocalTypes(),this._registerTypes(e),this._searchLocalSchemas(),this._registerSchemas(e)}_searchLocalTypes(){const e=g.join(this.__dirname,"types");if(f(e))return void console.warn(`Unable to find "types" folder for path "${e}"`);console.log(`Add types from: ${e}`);const r=v(e);let t="",s=void 0;for(let e=0,a=r.length;e<a;e++)t=r[e],s=require(t),this._types.push(s)}_registerTypes(e){for(let r of this._types)console.log(`Register type: ${r.name}`),r(e)}_searchLocalSchemas(){const e=g.join(this.__dirname,"schemas");if(f(e))return void console.warn(`Unable to find "schemas" folder for path "${e}"`);console.log(`Add schemas from: ${e}`);const r=v(e);let t="",s=void 0;for(let e=0,a=r.length;e<a;e++)t=r[e],_(t)?console.warn(`Skip empty local database schema: ${t}`):(s=require(t),this._schemas.push(s))}_registerSchemas(e){for(let r of this._schemas)console.log(`Register schema: ${r.name}`),a(r.registerModelTo)?r.registerModelTo(e):a(r)?r(e):console.error(`Unable to register local database schema: ${r}`)}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class R extends class{constructor(e={}){const r={driver:null,application:null,router:null,plugins:[],...e};this.driver=r.driver,this.application=r.application,this.router=r.router,this.plugins=r.plugins,this.init(),this._registerPlugins()}get plugins(){return this._plugins}set plugins(e){if(h(e))throw new TypeError("Plugins cannot be null ! Expect an array of TDatabasePlugin.");if(m(e))throw new TypeError("Plugins cannot be undefined ! Expect an array of TDatabasePlugin.");this._plugins=e}get router(){return this._router}set router(e){if(h(e))throw new TypeError("Router cannot be null ! Expect a Express Router.");if(m(e))throw new TypeError("Router cannot be undefined ! Expect a Express Router.");this._router=e}get application(){return this._application}set application(e){if(h(e))throw new TypeError("Application cannot be null ! Expect a Express Application.");if(m(e))throw new TypeError("Application cannot be undefined ! Expect a Express Application.");this._application=e}get driver(){return this._driver}set driver(e){if(h(e))throw new TypeError("Driver cannot be null ! Expect a database driver.");if(m(e))throw new TypeError("Driver cannot be undefined ! Expect a database driver.");this._driver=e}setPlugins(e){return this.plugins=e,this}setRouter(e){return this.router=e,this}setApplication(e){return this.application=e,this}setDriver(e){return this.driver=e,this}init(){}_registerPlugins(){for(let[e,r]of Object.entries(this._plugins))this._registerPackagePlugin(e,r)?console.log(`Use ${e} plugin from node_modules`):this._registerLocalPlugin(e,r)?console.log(`Use ${e} plugin from local folder`):console.error(`Unable to register the plugin ${e} the package or local folder doesn't seem to exist ! Skip it.`)}_registerPackagePlugin(e){let r=!1;try{const t=require(e);t instanceof D?(t.__dirname=g.dirname(require.resolve(e)),t.registerTo(this._driver,this._application,this._router),r=!0):console.error(`The plugin ${e} doesn't seem to be an instance of an extended class from TAbstractDatabasePlugin ! Skip it.`)}catch(e){e.code&&"MODULE_NOT_FOUND"===e.code||console.error(e)}return r}_registerLocalPlugin(e){let r=!1;try{const t=g.join(__dirname,"../../../","databases/plugins/",e,`${e}.js`),s=require(t);s instanceof D?(s.__dirname=g.dirname(require.resolve(t)),s.registerTo(this._driver,this._application,this._router),r=!0):console.error(`The plugin ${e} doesn't seem to be an instance of an extended class from TAbstractDatabasePlugin ! Skip it.`)}catch(e){console.error(e)}return r}connect(){}close(){}on(){}}{constructor(e={}){const r={databaseUrl:"",...e,driver:w};super(r),this.databaseUrl=r.databaseUrl}close(e){this._driver.connection.close(e)}connect(){this._driver.connect(this.databaseUrl,{useNewUrlParser:!0}).then(e=>{console.log(`MongoDB at ${this.databaseUrl} is connected ! ${e}`)}).catch(e=>{console.error(e)})}init(){super.init()}on(e,r){-1!==["connecting","connected","open","disconnecting","disconnected","reconnected","close","error"].indexOf(e)&&this._driver.connection.on(e,r)}}export{R as TMongoDBDatabase,N as TMongoDBPlugin,T as TMongooseController};
