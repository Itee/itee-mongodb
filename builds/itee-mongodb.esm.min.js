import{TAbstractDataController as e,TAbstractDatabasePlugin as t,TAbstractDatabase as r}from"itee-database";import{isNull as a,isUndefined as s,isEmptyArray as n}from"itee-validators";import i from"mongoose";import{getFilesPathsUnder as o}from"itee-utils";import{existsSync as h,statSync as c}from"fs";import{join as d}from"path";
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class TMongooseController
 * @classdesc The TMongooseController is the base class to perform CRUD operations on the database
 */class u extends e{constructor(e={}){const t={schemaName:"",...e,driver:i};super(t),this.databaseSchema=this._driver.model(t.schemaName)}get databaseSchema(){return this._databaseSchema}set databaseSchema(e){if(a(e))throw new TypeError("Database schema cannot be null.");if(s(e))throw new TypeError("Database schema cannot be undefined.");this._databaseSchema=e}setDatabaseSchema(e){return this.databaseSchema=e,this}_createMany(e,t){super._createMany(e,t),this._databaseSchema.create(e,this.return(t))}_createOne(e,t){super._createOne(e,t),this._databaseSchema.create(e,this.return(t))}_deleteAll(e){super._deleteAll(e),this._databaseSchema.collection.drop(u.return(e))}_deleteMany(e,t){super._deleteMany(e,t),this._databaseSchema.deleteMany({_id:{$in:e}},this.return(t))}_deleteOne(e,t){super._deleteOne(e,t),this._databaseSchema.findByIdAndDelete(e).then(e=>u.returnData(e,t)).catch(e=>u.returnError(e,t))}_deleteWhere(e,t){super._deleteWhere(e,t),this._databaseSchema.deleteMany(e,this.return(t))}_readAll(e,t){super._readAll(e,t),this._databaseSchema.find({},e).lean().exec().then(e=>u.returnData(e,t)).catch(e=>u.returnError(e,t))}_readMany(e,t,r){super._readMany(e,t,r),this._databaseSchema.find({_id:{$in:e}},t).lean().exec().then(t=>{a(t)||n(t)?u.returnNotFound(r):e.length!==t.length?u.returnErrorAndData({title:"Missing data",message:"Some requested objects could not be found."},t,r):u.returnData(t,r)}).catch(e=>u.returnError(e,r))}_readOne(e,t,r){super._readOne(e,t,r),this._databaseSchema.findById(e,t).lean().exec().then(e=>{a(e)?u.returnNotFound(r):u.returnData(e,r)}).catch(e=>u.returnError(e,r))}_readWhere(e,t,r){super._readWhere(e,t,r),this._databaseSchema.find(e,t).lean().exec().then(e=>u.returnData(e,r)).catch(e=>u.returnError(e,r))}_updateAll(e,t){super._updateAll(e,t),this._databaseSchema.update({},e,{multi:!0},u.return(t))}_updateMany(e,t,r){super._updateMany(e,t,r),this._databaseSchema.update({_id:{$in:e}},t,{multi:!0},u.return(r))}_updateOne(e,t,r){super._updateOne(e,t,r),this._databaseSchema.findByIdAndUpdate(e,t).exec().then(e=>u.returnData(e,r)).catch(e=>u.returnError(e,r))}_updateWhere(e,t,r){super._updateWhere(e,t,r),this._databaseSchema.update(e,t,{multi:!0},u.return(r))}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module sources/cores/functions/isFunction
 * @desc Export function to validate if a value is a function or not
 * @example
 *
 * import { isFunction } from 'itee-validators'
 *
 * if( isFunction( value ) ) {
 *     //...
 * } else {
 *     //...
 * }
 *
 */function l(e){return"function"==typeof e}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module sources/file-system/paths/isValidPath
 * @description Export function to validate if a value is a valid path
 *
 * @requires {@link module: [fs]{@link https://nodejs.org/api/fs.html}}
 *
 * @example
 *
 * import { isValidPath } from 'itee-validators'
 *
 * if( isValidPath( value ) ) {
 *     //...
 * } else {
 *     //...
 * }
 *
 */
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module sources/cores/voids/isDefined
 * @desc Export function to validate if a value is a defined or not
 * @example
 *
 * import { isDefined } from 'itee-validators'
 *
 * if( isDefined( value ) ) {
 *     //...
 * } else {
 *     //...
 * }
 *
 */
function p(e){return null!=e}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module sources/cores/strings/isString
 * @desc Export function to validate if a value is a string
 * @example
 *
 * import { isString } from 'itee-validators'
 *
 * if( isString( value ) ) {
 *     //...
 * } else {
 *     //...
 * }
 *
 */function m(e){return!function(e){return"string"==typeof e||e instanceof String}(e)}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module sources/file-system/directories/isDirectoryPath
 * @description Export function to validate if a value is a directories path
 *
 * @requires {@link module: [fs]{@link https://nodejs.org/api/fs.html}}
 *
 * @example
 *
 * import { isDirectoryPath } from 'itee-validators'
 *
 * if( isDirectoryPath( value ) ) {
 *     //...
 * } else {
 *     //...
 * }
 *
 */
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module sources/file-system/directories/isValidDirectoryPath
 * @description Export function to validate if a value is a valid directory path
 * @example
 *
 * import { isValidDirectoryPath } from 'itee-validators'
 *
 * if( isValidDirectoryPath( value ) ) {
 *     //...
 * } else {
 *     //...
 * }
 *
 */
function _(e){return function(e){return h(e)}(e)&&function(e){if(m(e)&&!(e instanceof Buffer)&&!(e instanceof URL))return!1;const t=c(e,{throwIfNoEntry:!1});return p(t)&&t.isDirectory()}(e)}function f(e){return!_(e)}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module sources/file-system/files/isFilePath
 * @description Export function to validate if a value is a file path
 *
 * @requires {@link module: [fs]{@link https://nodejs.org/api/fs.html}}
 *
 * @example
 *
 * import { isFilePath } from 'itee-validators'
 *
 * if( isFilePath( value ) ) {
 *     //...
 * } else {
 *     //...
 * }
 *
 */
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @module sources/file-system/files/isEmptyFile
 * @description Export function to validate if a value is an empty file
 *
 * @requires {@link module: [fs]{@link https://nodejs.org/api/fs.html}}
 *
 * @example
 *
 * import { isEmptyFile } from 'itee-validators'
 *
 * if( isEmptyFile( value ) ) {
 *     //...
 * } else {
 *     //...
 * }
 *
 */
function g(e,t=0){return(!m(e)||e instanceof Buffer||e instanceof URL)&&(function(e){if(m(e)&&!(e instanceof Buffer)&&!(e instanceof URL))return!1;const t=c(e,{throwIfNoEntry:!1});return p(t)&&t.isFile()}(e)&&c(e).size<=t)}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class b extends t{constructor(e={}){const t={types:[],schemas:[],...e};super(t),this.types=t.types,this.schemas=t.schemas}get schemas(){return this._schemas}set schemas(e){this._schemas=e}get types(){return this._types}set types(e){this._types=e}addSchema(e){return this._schemas.push(e),this}addType(e){return this._types.push(e),this}beforeRegisterRoutes(e){super.beforeRegisterRoutes(e),this._searchLocalTypes(),this._registerTypes(e),this._searchLocalSchemas(),this._registerSchemas(e)}_searchLocalTypes(){const e=d(this.__dirname,"types");if(f(e))return void this.logger.warn(`Unable to find "types" folder for path "${e}"`);this.logger.log(`Add types from: ${e}`);const t=o(e);let r,a="";for(let e=0,s=t.length;e<s;e++)a=t[e],r=require(a),this._types.push(r)}_registerTypes(e){for(let t of this._types)this.logger.log(`Register type: ${t.name}`),t(e)}_searchLocalSchemas(){const e=d(this.__dirname,"schemas");if(f(e))return void this.logger.warn(`Unable to find "schemas" folder for path "${e}"`);this.logger.log(`Add schemas from: ${e}`);const t=o(e);let r,a="";for(let e=0,s=t.length;e<s;e++)a=t[e],g(a)?this.logger.warn(`Skip empty local database schema: ${a}`):(r=require(a),this._schemas.push(r))}_registerSchemas(e){for(let t of this._schemas)this.logger.log(`Register schema: ${t.name}`),l(t.registerModelTo)?t.registerModelTo(e):l(t)?t(e):this.logger.error(`Unable to register local database schema: ${t}`)}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class y extends r{constructor(e={}){const t={databaseUrl:"",databaseOptions:{useNewUrlParser:!0,useUnifiedTopology:!0},...e,driver:i};super(t),this.databaseUrl=t.databaseUrl,this.databaseOptions=t.databaseOptions}close(e){this._driver.connection.close(e)}connect(){this._driver.connect(this.databaseUrl,this.databaseOptions).then(e=>{this.logger.log(e)}).then(()=>{const e=this.databaseUrl.match(/:(\w*)@/g),t=e?this.databaseUrl.replace(e[0],":*******@"):this.databaseUrl;this.logger.log(`MongoDB at ${t} is connected !`)}).catch(e=>{this.logger.error(e)})}init(){super.init()}on(e,t){-1!==["connecting","connected","open","disconnecting","disconnected","reconnected","close","error"].indexOf(e)&&this._driver.connection.on(e,t)}}export{y as TMongoDBDatabase,b as TMongoDBPlugin,u as TMongooseController};
