import{isNull as e,isUndefined as t,isEmptyArray as a,isInvalidDirectoryPath as s,isEmptyFile as r,isFunction as n}from"itee-validators";import{TAbstractDataController as h,TAbstractDatabasePlugin as o,TAbstractDatabase as c}from"itee-database";import{getFilesPathsUnder as i}from"itee-utils";import d from"path";import*as l from"mongoose";
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class TMongooseController
 * @classdesc The TMongooseController is the base class to perform CRUD operations on the database
 */class u extends h{constructor(e={}){const t={driver:null,schemaName:"",...e};super(t),this.databaseSchema=this._driver.model(t.schemaName)}get databaseSchema(){return this._databaseSchema}set databaseSchema(a){if(e(a))throw new TypeError("Database schema cannot be null.");if(t(a))throw new TypeError("Database schema cannot be undefined.");this._databaseSchema=a}setDatabaseSchema(e){return this.databaseSchema=e,this}_createMany(e,t){super._createMany(e,t),this._databaseSchema.create(e,this.return(t))}_createOne(e,t){super._createOne(e,t),this._databaseSchema.create(e,this.return(t))}_deleteAll(e){super._deleteAll(e),this._databaseSchema.collection.drop(this.return(e))}_deleteMany(e,t){super._deleteMany(e,t),this._databaseSchema.deleteMany({_id:{$in:e}},this.return(t))}_deleteOne(e,t){super._deleteOne(e,t),this._databaseSchema.findByIdAndDelete(e).then(e=>h.returnData(e,t)).catch(e=>h.returnError(e,t))}_deleteWhere(e,t){super._deleteWhere(e,t),this._databaseSchema.deleteMany(e,this.return(t))}_readAll(e,t){super._readAll(e,t),this._databaseSchema.find({},e).lean().exec().then(e=>h.returnData(e,t)).catch(e=>h.returnError(e,t))}_readMany(t,s,r){super._readMany(t,s,r),this._databaseSchema.find({_id:{$in:t}},s).lean().exec().then(s=>{e(s)||a(s)?h.returnNotFound(r):t.length!==s.length?h.returnErrorAndData({title:"Missing data",message:"Some requested objects could not be found."},s,r):h.returnData(s,r)}).catch(e=>h.returnError(e,r))}_readOne(t,a,s){super._readOne(t,a,s),this._databaseSchema.findById(t,a).lean().exec().then(t=>{e(t)?h.returnNotFound(s):h.returnData(t,s)}).catch(e=>h.returnError(e,s))}_readWhere(e,t,a){super._readWhere(e,t,a),this._databaseSchema.find(e,t).lean().exec().then(e=>h.returnData(e,a)).catch(e=>h.returnError(e,a))}_updateAll(e,t){super._updateAll(e,t),this._databaseSchema.update({},e,{multi:!0},this.return(t))}_updateMany(e,t,a){super._updateMany(e,t,a),this._databaseSchema.update({_id:{$in:e}},t,{multi:!0},this.return(a))}_updateOne(e,t,a){super._updateOne(e,t,a),this._databaseSchema.findByIdAndUpdate(e,t).exec().then(e=>h.returnData(e,a)).catch(e=>h.returnError(e,a))}_updateWhere(e,t,a){super._updateWhere(e,t,a),this._databaseSchema.update(e,t,{multi:!0},this.return(a))}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class _ extends o{constructor(e={}){const t={types:[],schemas:[],...e};super(t),this.types=t.types,this.schemas=t.schemas}get schemas(){return this._schemas}set schemas(e){this._schemas=e}get types(){return this._types}set types(e){this._types=e}addSchema(e){return this._schemas.push(e),this}addType(e){return this._types.push(e),this}beforeRegisterRoutes(e){super.beforeRegisterRoutes(e),this._searchLocalTypes(),this._registerTypes(e),this._searchLocalSchemas(),this._registerSchemas(e)}_searchLocalTypes(){const e=d.join(this.__dirname,"types");if(s(e))return void console.warn(`Unable to find "types" folder for path "${e}"`);console.log(`Add types from: ${e}`);const t=i(e);let a="",r=void 0;for(let e=0,s=t.length;e<s;e++)a=t[e],r=require(a),this._types.push(r)}_registerTypes(e){for(let t of this._types)console.log(`Register type: ${t.name}`),t(e)}_searchLocalSchemas(){const e=d.join(this.__dirname,"schemas");if(s(e))return void console.warn(`Unable to find "schemas" folder for path "${e}"`);console.log(`Add schemas from: ${e}`);const t=i(e);let a="",n=void 0;for(let e=0,s=t.length;e<s;e++)a=t[e],r(a)?console.warn(`Skip empty local database schema: ${a}`):(n=require(a),this._schemas.push(n))}_registerSchemas(e){for(let t of this._schemas)console.log(`Register schema: ${t.name}`),n(t.registerModelTo)?t.registerModelTo(e):n(t)?t(e):console.error(`Unable to register local database schema: ${t}`)}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class m extends c{constructor(e={}){const t={databaseUrl:"",...e,driver:l};super(t),this.databaseUrl=t.databaseUrl}close(e){this._driver.connection.close(e)}connect(){this._driver.connect(this.databaseUrl,{useNewUrlParser:!0}).then(e=>{console.log(`MongoDB at ${this.databaseUrl} is connected ! ${e}`)}).catch(e=>{console.error(e)})}init(){super.init()}on(e,t){-1!==["connecting","connected","open","disconnecting","disconnected","reconnected","close","error"].indexOf(e)&&this._driver.connection.on(e,t)}}export{m as TMongoDBDatabase,_ as TMongoDBPlugin,u as TMongooseController};
